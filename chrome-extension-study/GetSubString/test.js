//문자열이 변수에 담겼으면,,

// let str에 찾으려는 본문이 온다.
let str_arr = [
  `정용진 신세계그룹 부회장이 온라인상에서 공유되고 있는 본인과 신세계그룹 계열사에 대한 불매운동 관련 이미지를 자신의 인스타그램에 올렸다.
자신의 '멸공' 관련 발언을 둘러싼 논란이 정치권으로까지 번지고 신세계그룹 주가가 급락하면서 관련 발언을 더는 하지 않겠다고 선언하며 수습에 나선 지 반나절만이다.
정 부회장은 11일 오전 자신의 인스타그램에 '보이콧 정용진, 가지 않습니다. 사지 않습니다'는 문구가 담긴 이미지를 올리며 "업무에 참고하시기 바랍니다"라고 적었다.
이 이미지는 2019년 일본 불매운동 당시의 '노재팬' 포스터를 모방한 것으로, 정 부회장의 '멸공' 발언이 논란이 된 이후 온라인상에서 공유되고 있다.
정 부회장은 또 이날 오전 북한이 동해상으로 탄도미사일로 추정되는 발사체를 발사했다는 기사 내용을 캡처해 올리며 '○○'이라고 적었다.
'멸공'이라는 단어를 직접 쓰는 대신 '○○'으로 표기한 것으로 풀이된다. 정 부회장은 앞서 지난 6일 시진핑 중국 국가주석 사진이 들어간 기사를 자신의 인스타그램에 올리면서 '멸공', '방공방첩', '승공통일' 등의 해시태그를 함께 달았다.
이후 논란이 확산하자 해당 게시물을 삭제하고 김정은 북한 국무위원장의 사진을 올리며 자신의 멸공은 중국이 아닌 '우리 위에 사는 애들'(북한)을 겨냥한 것이라고 해명했다. 
그러나 윤석열 국민의힘 대선 후보가 8일 이마트[139480]를 찾아 '멸공'을 연상시키는 멸치와 콩을 구입하면서 논란이 정치권으로까지 확산했다. 
이에 전날 유가증권시장에서는 신세계[004170] 주가가 전 거래일보다 6.80% 하락했고, 온라인상에서도 스타벅스 등 신세계그룹 계열사에 대한 불매운동을 주장하는 글이 다수 올라왔다. 
정 부회장은 이처럼 논란이 지속되자 전날 오후 늦게 주변에 "더 이상 '멸공' 관련 발언은 하지 않을 것"이라고 말한 것으로 알려졌다.`,
  `지지율 정체로 고민하던 심상정 정의당 대선 후보가 일정 중단을 발표한 뒤, 정의당은 13일 선거대책위원장을 비롯한 선대위원 일괄 사퇴를 선언하는 등 혼란스러운 형국이다. 칩거 중인 심 후보가 언제, 어떤 입장을 표명할지 관심이 쏠리고 있다.
이동영 정의당 수석대변인은 이날 기자단에 공지를 보내 "당 선대위는 현재 선거 상황의 심각성을 인식하고 선대위원장을 비롯한 선대위원이 일괄 사퇴하기로 뜻을 모았다"고 밝혔다.
앞서 심 후보는 전날(12일) 선대위를 통해 "현 선거 상황을 심각하게 받아들이고, 이 시간 이후 모든 일정을 중단하고 숙고에 들어가겠다"고 밝힌 바 있다.

한길리서치가 쿠키뉴스 의뢰로 지난 8~10일 전국 18세 이상 남녀 1014명을 대상으로 한 여론조사에서 심 후보는 2.2%를 기록해 허경영 국가혁명당 후보(3.2%)보다 낮은 지지율을 기록했다. 19대 대선에서 6.17%를 득표한 심 후보로서는 충격적인 결과다.

심 후보는 전날 한국기자협회 초청 토론회에서 지지율 답보 상태 해결책에 대한 질문에 "기본적으로 정권교체와 시대변화에 대한 열망이 후보들의 지지율을 움직이고 있다고 생각한다"며 "제가 그 대안으로서 국민들께 아직 믿음을 드리지 못하고 있어서 답답하고 많은 고민이 된다. 곧 여러모로 성찰 결과를 국민 여러분께 말씀드리겠다"고 말하기도 했다.

여영국 정의당 대표는 이날 심 후보와 연락을 시도했으나 닿지 않았고 오전 10시부터 선대위 차원의 논의를 진행한 결과 선대위원 일괄 사퇴를 결정했다.

여 대표는 회의 전 기자들과 만나 "후보께서 모든 것을 열어놓고 판단하실 것이고 어떤 판단을 하든 당은 존중하려 한다"면서도 "그동안 후보께서 이번 대선 출마가 자신의 마지막 소임이라고 몇 번을 말씀하셨다. 그런 점에서 (완주할 것이라고) 심 후보를 믿는다"고 말했다.

여 대표가 오후에 개최한다고 예고했던 의원단 연석회의는 열리지 않는다. 정의당 관계자는 "선대위 일괄 사퇴 이후, 여 대표는 책임있게 당내 상황 공유와 의견 수렴을 위한 다양한 소통을 진행할 계획"이라고 설명했다.`,
];

//찾으려는 키(키워드)
// 키워드 배열로 가능
let key_arr = ["멸공", "논란", "후보"];

// let key 배열에 사용자가 찾으려는 키워드를 넣으면 된다. 키워드가 1개가 아니라 여러개여도 대응이 가능

let ResultSubStr = [];
let ResultKeyPoint = [];
let ResultKeyCount = [];

for (let str of str_arr) {
  for (let key of key_arr) {
    let index = 0;

    let key_point = []; // 본문에서 key의 위치를 받아두는 배열
    let Sub_str = []; // 키워드 포함 하위 문장이 들어가는 배열
    let SubStrSize = 30; // 전체 사이즈
    let FrontSubStrLen = 20; // 앞쪽 사이즈
    let FixIndex = 0; // 최종길이.
    let KeyWordCount = 0;
    let flag = false;

    while (index != -1) {
      flag = true;
      index = str.indexOf(key, index + 1);
      if (index != -1) {
        key_point.push(index); // 필요할수도 있으니까,,
        FixIndex = index - FrontSubStrLen;
        // 키워드 위치 고정을 위한 수식. 음수일 경우 그대로이기 때문에 넣은 코드
        if (FixIndex < 0) {
          FixIndex = 0;
        }
        KeyWordCount += 1;
        Sub_str.push(str.substr(FixIndex, SubStrSize));
      }
    }
    if (flag) {
      ResultKeyCount.push(KeyWordCount);
      ResultSubStr.push(Sub_str);
      ResultKeyPoint.push(key_point);
    }
  }
}

console.log(ResultKeyCount);
console.log(ResultKeyPoint);
console.log(ResultSubStr);

/*

ResultKeyCount에는 key_arr와 str_arr에 대응합니다.
몇번째 문단에서 찾으려는 단어가 몇번 등장하는지 횟수를 기록한 배열입니다.
ex) key_arr 0 번째에 "협찬"이라는 단어가 들어 있다면, str_arr 0번째 글에 "협찬"이 몇번 등장하는지 횟수를
ResultKeyCount의 0번째에 담아놓았습니다.

ResultSubStr에는 key_arr와 str_arr에 대응합니다.
몇번째 문단에서 찾으려는 단어가 포함된 문장을 담은 배열입니다.
ex) key_arr 0 번째에 "협찬"이라는 단어가 들어 있다면, str_arr 0번째에 해당 단어가 등장하는 하위문장들을
담아둔 배열입니다. ResultSubStr의 0번째 단어가 0번째 문단에 등장한 하위문장들을 0번째에 담아놓았습니다.

ResultKeyPoint에는 key_arr와 str_arr에 대응합니다.
몇번째 문단에서 찾으려는 단어가 등장하는지 위치들을 기록해둔 배열입니다.
ex) key_arr 0 번째에 "협찬"이라는 단어가 들어 있다면, str_arr 0번째의 해당 단어 위치들을 담아둔 배열입니다.
ResultKeyPoint의 0번째에 0번째 단어의 0번째 문단에서의 위치들을 담아놓았습니다.


*/

// 유저가 입력한 키워드가 등장하는 위치가 담긴 배열
// 등장 횟수
// 키워드가 들어간 하위문장 앞뒤로 설정한 범위만큼
// let ParaNum = str_arr.length;
// let KeyNum = key_arr.length;

/*
ResultKeyCount배열을 순회하면서 keyNum갯수만큼 체크를한다.
*/

//
let NumOfKey = key_arr.length;
// 3개
let FixOp = [];
let count = 0;

for (let j = 0; j < str_arr.length; j++) {
  // 몇번째 사이트를 볼건지.
  let op_cnt = 0;
  while (count <= ResultKeyCount.length) {
    // 해당 사이트에 단어가 등장한 유무를 검사
    if (ResultKeyCount[count] > 0) {
      op_cnt += 1;
    }
    if ((count + 1) % NumOfKey === 0) {
      let temp = (1 - op_cnt / NumOfKey) * 100;
      FixOp.push(Math.round(temp).toString(16));
      break;
    }
    count++;
  }
}

console.log("\n");
console.log("\n");
console.log("\n");
console.log(FixOp);
